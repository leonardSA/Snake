<?xml version="1.0"?><st-source><component-created><name>Projets2018</name> <type>package</type></component-created><class><name>CellImage</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellImage position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>CellImage</class-id><body>CellImage est le grain cellulaire dans le module. Cette classe devrait etre travaillée en fonction des applications viséesInstance Variables:	cellImage	&lt;Image&gt;	image extraite lors de la segmentation	position	&lt;Point&gt;	  position initiale de la cellule dans l'image</body></comment><class><name>UIProjets1</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>laVue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>UIProjets1</class-id><body>UIProjets1 Souche d'application destinée à etre spécialiséeInstance Variables:	laVue	&lt;GrilleImageView&gt;	  laVue présentée</body></comment><class><name>GrilleImageView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interCellOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>GrilleImageView</class-id><body>GrilleImageView on y affiche l'image segmentée, ou non segmentéeInstance Variables:	interCellOffset	&lt;Point&gt;	intestice entre les images élémentaires 1@1 par défaut</body></comment><class><name>GrilleImage</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>imageFileName cellSize cellArray image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>GrilleImage</class-id><body>GrilleImage est le modele initial pour l'applicationInstance Variables:	cellArray	&lt;Array of: Array of: CellImage&gt;	description of cellArray	cellSize	&lt;Point&gt;	dimension de la cellule	image	&lt; Image&gt;	  image initiale complete	imageFileName	&lt;String&gt;	nom du fichier exterieur si il existe</body></comment><methods><class-id>CellImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="cellImage:position:">cellImage: image position: position	^(self new)		cellImage: image;		position: position</body></methods><methods><class-id>CellImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface opening</category><body package="Projets2018" selector="open">open	| interface |	interface := self basicNew initialize.	interface isNil ifFalse: [interface open]</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface opening</category><body package="Projets2018" selector="openFrom:">openFrom: fileName	| interface |	interface := self basicNew.	interface initializeFrom: fileName.	interface open</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface specs</category><body package="Projets2018" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'kit Project' 			#bounds: #(#{Graphics.Rectangle} 792 318 1233 730 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 4 0 435 0 408 0 ) 					#name: #ViewHolder1 					#component: #laVue ) ) ) )</body></methods><methods><class-id>UIProjets1 class</class-id> <category>resources</category><body package="Projets2018" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Save' ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Intersise' 							#value: #doIntestice ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>GrilleImageView class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	^self basicNew initialize</body></methods><methods><class-id>GrilleImage class</class-id> <category>testing</category><body package="Projets2018" selector="testCreateDialog">testCreateDialog	" self testCreateDialog "	^self fromFile</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromFile">fromFile	| file reader gimage fileName |	fileName := Dialog requestFileName: 'Choisir une image'.	fileName isEmpty		ifTrue: [^nil]		ifFalse: 			[file := fileName asFilename.			file exists				ifTrue: 					[reader := ImageReader fromFile: file.					gimage := self new.					gimage imageFileName: fileName.					gimage image: reader image.					gimage setUpGrid.					^gimage]]</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	^self basicNew initialize.</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromUser">fromUser	| gimage fileName image |	fileName := 'fromUser'.	image := Image fromUser.	gimage := self new.	gimage imageFileName: fileName.	gimage image: image.	gimage setUpGrid.	^gimage</body></methods><methods><class-id>GrilleImage class</class-id> <category>testing</category><body package="Projets2018" selector="testCreate">testCreate	^self fromFile: 'xxx.png'</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromFile:">fromFile: fileName	| file reader gimage |	file := fileName asFilename.	file exists		ifTrue: 			[reader := ImageReader fromFile: file.			gimage := self new.			gimage imageFileName: fileName.			gimage image: reader image.			gimage setUpGrid.			^gimage]		ifFalse: 			[Dialog warn: 'cannot find ' , fileName.			gimage := self new.			gimage imageFileName: nil.			gimage image: nil.			^gimage]</body></methods><methods><class-id>CellImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	cellImage := nil.	position := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellImage">cellImage	^cellImage</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="position:">position: anObject	position := anObject</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="position">position	^position</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellImage:">cellImage: anObject	cellImage := anObject</body></methods><methods><class-id>UIProjets1</class-id> <category>accessing</category><body package="Projets2018" selector="laVue">laVue	^laVue</body></methods><methods><class-id>UIProjets1</class-id> <category>accessing</category><body package="Projets2018" selector="laVue:">laVue: anObject	laVue := anObject</body></methods><methods><class-id>UIProjets1</class-id> <category>initialize-release</category><body package="Projets2018" selector="initializeFrom:">initializeFrom: fileName	| monModele |	monModele := (GrilleImage fromFile: fileName) asValue.	laVue := GrilleImageView new.	laVue interCellOffset: 1 @ 1.	laVue model: monModele</body></methods><methods><class-id>UIProjets1</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	| monModele choice |	choice := Dialog				choose: 'Choisir une image:'				labels: (Array with: 'from user' with: 'from a file' with: 'xxx.png')				values: #(#fromUser #testCreateDialog #testCreate)				default: #testCreateDialog.	choice isEmpty		ifTrue: [^nil]		ifFalse: 			[monModele := (GrilleImage perform: choice) asValue.			laVue := GrilleImageView new.			laVue interCellOffset: 1 @ 1.			laVue model: monModele.			self]</body></methods><methods><class-id>UIProjets1</class-id> <category>actions</category><body package="Projets2018" selector="doRandomPoint">doRandomPoint	| grille randPoint |	grille := self laVue value.	randPoint:=grille randomCell.	Dialog warn: randPoint printString</body></methods><methods><class-id>UIProjets1</class-id> <category>actions</category><body package="Projets2018" selector="doIntestice">doIntestice	| interCell choix rs x y |	interCell := self laVue interCellOffset.	choix := Dialog request: 'interstice?' initialAnswer: interCell printString.	choix isEmpty		ifFalse: 			[rs := choix readStream.			x := (rs upTo: $@) asNumber.			y := rs upToEnd asNumber.			self laVue interCellOffset: (x @ y) .			self laVue model value: self laVue model value]</body></methods><methods><class-id>GrilleImageView</class-id> <category>accessing</category><body package="Projets2018" selector="interCellOffset">interCellOffset	^interCellOffset</body></methods><methods><class-id>GrilleImageView</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self interCellOffset: 0@0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>GrilleImageView</class-id> <category>accessing</category><body package="Projets2018" selector="interCellOffset:">interCellOffset: anObject	interCellOffset := anObject</body></methods><methods><class-id>GrilleImageView</class-id> <category>displaying</category><body package="Projets2018" selector="displayOn:">displayOn: aGC	| grille cellSize offset yPos xPos |	grille := self model value cellArray.	grille isNil ifTrue: [ ^  nil].	cellSize := self model value cellSize.	offset := cellSize + self interCellOffset.	yPos := 0.	grille do: 			[:line |			xPos := 0.			line do: 					[:cell |					cell cellImage displayOn: aGC at: xPos @ yPos.					xPos := xPos + offset x].			yPos := yPos + offset y]</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="imageFileName">imageFileName	^imageFileName</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellArray">cellArray	^cellArray</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellArray:">cellArray: anObject	cellArray := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="image">image	^image</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellSize:">cellSize: anObject	cellSize := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="setupFromInage">setupFromInage	  	| xDim yDim |	cellSize := 10@10.	xDim := (self image width / cellSize x ) + 1.	yDim := (self image height / cellSize y ) + 1.	cellArray := ( 1 to: yDim) collect: [ :rowIndex | (1 to: xDim) asArray].	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	imageFileName := nil.	cellSize := 10@10.	cellArray := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="imageFileName:">imageFileName: anObject	imageFileName := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellSize">cellSize	^cellSize</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="image:">image: anObject	image := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="setupEmpty">setupEmpty	  	| xDim yDim |	cellSize := 10@10.	xDim := (self image width / cellSize x ) + 1.	yDim := (self image height / cellSize y ) + 1.	cellArray := ( 1 to: yDim) collect: [ :row | (1 to: xDim) asArray].	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>converting</category><body package="Projets2018" selector="setUpGrid">setUpGrid	| bounds nbLines nbCol wsLines yIndex xIndex wsCols newImage thisImage cellImage |	self image isNil ifTrue: [^false].	bounds := self image bounds.	nbLines := ((1 + bounds height) / self cellSize y) truncated.	nbCol := ((1 + bounds width) / cellSize x) truncated.	wsLines := (Array new: nbLines) writeStream.	yIndex := 0.	nbLines timesRepeat: 			[xIndex := 0.			wsCols := (Array new: nbCol) writeStream.			nbCol timesRepeat: 					[newImage := Image								extent: self cellSize								depth: image depth								bitsPerPixel: image bitsPerPixel								palette: image palette copy.					thisImage := newImage								copy: (0 @ 0 extent: self cellSize)								from: xIndex @ yIndex								in: image								rule: RasterOp paint.					cellImage := CellImage cellImage: thisImage position: xIndex @ yIndex.					wsCols nextPut: cellImage.					xIndex := xIndex + self cellSize x].			wsLines nextPut: wsCols contents.			yIndex := yIndex + self cellSize y].	self cellArray: wsLines contents</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="width">width^self cellArray first size.</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="height">height^self cellArray size.</body></methods><methods><class-id>GrilleImage</class-id> <category>utilities</category><body package="Projets2018" selector="randomCell">randomCell| rand rx ry |	rand := Random new.rx:= (rand * self width ) truncated + 1.ry:= (rand * self height ) truncated + 1.^rx@ry</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="Projets2018" selector="menuItemProject">menuItemProject	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openProject		label: #(#_Project #menus '&amp;Project')		icon: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspace)		nameKey: nil		menu: #(#menuBar #tools)		position: 11.1&gt;		self openApplicationForClassNamed: #UIProjets1</body></methods><pundle-loaded><name>Projets2018</name><type>package</type><primaryKey>4</primaryKey><databaseId>#student2018</databaseId></pundle-loaded><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/INCASE/INCASE.im' 'April 5, 2018' '8:21:33 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/INCASE/INCASE.im was created at 8:21:33 AM on April 5, 2018."</do-it><component-created><name>Snake</name> <type>package</type></component-created><component-property><name>Snake</name> <type>package</type><property>comment</property> <value>'Snake game - OOP Project - L2 2018'</value></component-property><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><comment><class-id>SnakeUI</class-id><body>SnakeUI is the application model for our Snake game</body></comment><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 35 151 907 613 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 244 113 1044 643 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 500 0 500 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><do-it>SnakeUI organization addCategory: #accessing</do-it><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground">playground	^playground</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground:">playground: anObject	playground := anObject</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground">playground	^playground</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Snake class</class-id> <category>instance creation</category><body package="Snake" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeController</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>SnakeView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeView</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>SnakeView organization addCategory: #'controller accessing'</do-it><methods><class-id>SnakeView</class-id> <category>controller accessing</category><body package="Snake" selector="defaultControllerClass">defaultControllerClass	^SnakeController</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		playground := SnakeView new</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><do-it>Snake organization addCategory: #accessing</do-it><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="board">board	^board</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="board:">board: anObject	board := anObject</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="position">position	^position</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="position:">position: anObject	position := anObject</body></methods><do-it>Snake class organization addCategory: #testing</do-it><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard""</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: (Array new: 300). "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: (Array new: 300). "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><do-it>	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</do-it><do-it>SnakeView organization addCategory: #displaying</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board |	board :=self model value. "On recupere le modele du controlleur" </body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |				]		]			</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"				]		]			</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im' 'April 5, 2018' '9:57:54 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im was created at 9:57:54 AM on April 5, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im' 'April 5, 2018' '9:58:21 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im was created at 9:58:21 AM on April 5, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"	"	0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					trouver comment afficher le carre				]		]"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"									]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new	</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new.	playground model: board.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 200.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@(-10) corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: 50 @ 70				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: 50 @ 70				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos				].			xpos := xpos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><do-it>SnakeUI organization addCategory: #changing</do-it><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	| board|	board := self playground model value.	self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new.	playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.					pixel asFiller displayOn: aGC.					xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel  xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>controller accessing</category><body package="Snake" selector="defaultControllerClass">defaultControllerClass	^Snake</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		 1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		xpos := position x.	ypos := position y.	 1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '2:17:35 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 2:17:35 PM on April 21, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	" position := board position. starting position of the board defined in Snake"	board inspect.	ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	" position := board position. starting position of the board defined in Snake"	board inspect.	ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		pixel asFiller displayOn: aGC at: 5@5.		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		pixel asFiller displayOn: aGC at: 5@5.		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.				ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	(board size) inspect.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="width">width	^width</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="width:">width: anObject	width := anObject</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="height">height	^height</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="height:">height: anObject	height := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board board width: 300.	board board height: 500.	board position: 30 @ 30.	^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	width := board width.	height := board height.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	width := 300.	height := 500.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>width</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>width</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>height</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>height</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board width: 300.	board height: 500.	board position: 30 @ 30.	^board</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 88 73 1240 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 730 0 630 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 88 73 1240 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 730 0 630 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:02:31 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:02:31 PM on April 21, 2018."</do-it><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.	^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: height@width.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: (height*5)@(width*5).	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 0 0 800 0 700 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 0 0 800 0 700 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 731 0 631 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].			board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(playground at: 1) do: [:col | (playground at:1) at: col put: -1  ].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	"(playground at: 1) do: [:col | (playground at:1) at: col put: -1  ]."		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(playground at: 1) do: [:col | (playground at:1) at: col put: 0 ].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					(column isNil) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					( (board board at: line) at: column isNil) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						pixel asFiller displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						pixel asFiller displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:00 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:00 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:00 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:00 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:59:43 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:59:43 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '2:16:09 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 2:16:09 PM on April 23, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height snake </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="snake">snake	^snake</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="snake:">snake: anObject	snake := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	(1 to: 3) do: [ :i | snake add: i].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( ((board board at: line) at: column)).					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 0@0.	snake add: 1@0.	snake add: 2@0.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue blue.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue green.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue blue.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@0.	snake add: 51@0.	snake add: 52@0.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@20.	snake add: 51@20.	snake add: 52@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		(Rectangle origin: 100@100 corner: pixelWidth@pixelWidth) displayFilledOn: aGC.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>position</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>position</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><remove-selector><class-id>Snake</class-id> <selector>position:</selector></remove-selector><remove-selector><class-id>Snake</class-id> <selector>position</selector></remove-selector><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		^board</body></methods><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground play </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="play">play	^play</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="play:">play: anObject	play := anObject</body></methods><do-it>SnakeUI organization addCategory: #actions</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board |	board := self playground model value.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake |	board := self playground model value.	snake := board snake.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake |	board := self playground model value.	snake := board snake.		</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="direction">direction	^direction</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="direction:">direction: anObject	direction := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 15.		^board</body></methods><comment><class-id>Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of board	direction	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	gives direction of snake : 0 -&gt; up ; 15 -&gt; right ; 30 -&gt; down ; 45 -&gt; left	height	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of height	snake	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snake	width	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of width</body></comment><comment><class-id>Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of board	direction	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	gives direction of snake : 0 -&gt; up ; 1 -&gt; right ; 2 -&gt; down ; 3 -&gt; left	height	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of height	snake	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snake	width	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of width</body></comment><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	snake := board direction.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[				].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[		snake do: []		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[		snake do: [ :pos | ]		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[			(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)].		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[					].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ]. </body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ].		^gameOver </body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing	| delay gameOver |	self		processMove: 			[delay := Delay forMilliseconds: 100.			[true] whileTrue: 					[delay wait.					self move.]]					fork.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]</body></methods><remove-selector><class-id>SnakeUI</class-id> <selector>playing</selector></remove-selector><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:36:17 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:36:17 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:37:03 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:37:03 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		(self builder componentAt: #StartButton) disable.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:39:56 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:39:56 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>SnakeUI organization addCategory: #changing</do-it><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 10000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:57:31 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:57:31 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	snake add: 25@25.		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board tmp snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	tmp := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ tmp add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ tmp add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ tmp add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ tmp add: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].				"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].		(2 to: snake size) do: [ :i | newSnake add: (snake at: i) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 10.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 10.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '1:54:15 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:54:15 PM on April 24, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '1:54:25 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:54:25 PM on April 24, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '5:13:02 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 5:13:02 PM on April 24, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := board snake.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := board snake asValue.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := Snake testBoard snake asValue.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: GAMEOVER ]."		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardY) at: boardX = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardY) at: boardX = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	boardY inspect.	boardX inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	boardY inspect.	boardX inspect.	snake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	snake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect."	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 79 47 1231 705 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcessus">killProcessus</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "</body></methods><remove-selector><class-id>SnakeUI</class-id> <selector>killProcessus</selector></remove-selector><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		self play terminate.	(self builder componentAt: #startButton) enable</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:24:52 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:24:52 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		newSnake inspect.		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:38:34 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:38:34 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:39:50 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:39:50 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect.	"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:41:30 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:41:30 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect.	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect.	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 1000.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 10000.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@21.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@25.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.	snake add: 60@20.	snake add: 55@20.	snake add: 50@25.						board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	"boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	"boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: boardX) at: boardY = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '10:02:19 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 10:02:19 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 12) at: 4 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: boardX) at: boardY = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 0) at: 0 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ]."		model snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((tmp at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	wallCheck inspect.	((wallCheck at: boardY) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	((wallCheck at: boardY) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ SnakeUI killProcess ].		model snake: newSnake.	self playground model value: model.</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction gameover </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="gameover">gameover	^gameover</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="gameover:">gameover: anObject	gameover := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board gameover: true.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ model gameover: true ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(gameover) ifTrue: [].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [	self play terminate.	(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	model gameover: true.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board gameover: false.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	model gameover: false.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ model gameover: true ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.	board gameover: false.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	self play terminate.	(self builder componentAt: #startButton) enable</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>gameover</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>gameover</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><remove-selector><class-id>Snake</class-id> <selector>gameover</selector></remove-selector><remove-selector><class-id>Snake</class-id> <selector>gameover:</selector></remove-selector><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	self play terminate.	self initialize.	(self builder componentAt: #startButton) enable</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.	Transcript show: 'post terminate message in killProcess'</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.	Transcript show: 'post terminate message in killProcess'</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self initialize.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self initialize.	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	self initialize.	Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self initialize.	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '10:59:20 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 10:59:20 AM on April 26, 2018."</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	(event = #keyDown) ifTrue: [ self direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ self direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board. 	</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="changeDirection:">changeDirection: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>changeDirection:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event	(event ) ifTrue: [ ]  </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent eventType.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent eventType.	Transcript show: key printString.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent .	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyboardEvent isKeyPress .	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := 'event !'.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := 'event !'.	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>keyPressedEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboardPressed	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboardPressed			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboard digitValue.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := self sensor keyboard digitValue.	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	 self sensor cursorPointFor: event.	Transcript show:'hi'.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 self sensor cursorPointFor: event.	Transcript show:'hi'.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="controlActivity">controlActivity</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>controlActivity</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 "self sensor cursorPointFor: event.	Transcript show:'hi'."	| key |	key := self processKeyboardEvent: event.	key inspect.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 "self sensor cursorPointFor: event.	Transcript show:'hi'."	| key |	key := self KeyPressedEvent isKeyPress.	(key = true)			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	| key |	key := self sensor eventKeyPress: event.	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseMovedEvent:">mouseMovedEvent: event	Transcript show: 'Does it work ?'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>keyboardEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseMovedEvent:">mouseMovedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseButtonRelease:">mouseButtonRelease: event	Transcript show: 'Working'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseButtonReleaseEvent:">mouseButtonReleaseEvent: event	Transcript show: 'Working'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>mouseButtonReleaseEvent:</selector></remove-selector><remove-selector><class-id>SnakeController</class-id> <selector>mouseButtonRelease:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="processKeyboardEvent:">processKeyboardEvent: event	Transcript show: 'A key has been pressed'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>processKeyboardEvent:</selector></remove-selector><remove-selector><class-id>SnakeController</class-id> <selector>keyPressedEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keypress.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor digitValue.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keyboard digitValue.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keyboard digitValue.	"Transcript show: key printString."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	Transcript show: event printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	key := event keyCharacter.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event keyCharacter.	key inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event keyCharacter.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event eventType.	key inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	event keyValue inspect.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := event keyValue inspect.	(key = #Down) ifTrue: [ ]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board |		board := self model value.	key := event keyValue inspect.	(key = #Down) ifTrue: [ ]</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newDrection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><do-it>SnakeController addInstVarName: 'newDrection'</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDrection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1].		self model value: board. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		self model value: board.</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		newDirection inspect.		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:37:06 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:37:06 PM on April 26, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:37:12 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:37:12 PM on April 26, 2018."</do-it><remove-selector><class-id>SnakeController</class-id> <selector>mouseMovedEvent:</selector></remove-selector><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:38:03 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:38:03 PM on April 26, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '5:44:11 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 5:44:11 PM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 20.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"			(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"			|  board |		board := Snake testBoard asValue.	self playground model: board.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	"resets the game position"		|  board |	board := Snake testBoard asValue.	self playground model: board.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><comment><class-id>SnakeController</class-id><body>SnakeController allows us to control our Snake in the application. It is useful for moving the snake around.</body></comment><comment><class-id>SnakeView</class-id><body>SnakeView allows us to display our game on the UI.ApplicationModel SnakeUI view.</body></comment><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction food </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="food">food	^food</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="food:">food: anObject	food := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board food: 50@50. 		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board food: 50@50. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 50@50. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga foodX foodY|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		foodX := board food x.	foodY := board food y.				</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x / 5.	ypos := board food y / 5.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos			</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 100@100. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.		self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 27, 2018' '11:25:22 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 11:25:22 AM on April 27, 2018."</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection &lt;&gt; 1) ) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection ~= 1) ) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection ~= 0) ) ifTrue: [ newDirection := 2 ].	(key == #Up &amp; (newDirection ~= 2) ) ifTrue: [ newDirection := 0 ].	(key == #Left &amp; (newDirection ~= 1) ) ifTrue: [ newDirection := 3 ].	(key == #Right &amp; (newDirection ~= 3) ) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods>