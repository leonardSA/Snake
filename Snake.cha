<?xml version="1.0"?><st-source><component-created><name>Projets2018</name> <type>package</type></component-created><class><name>CellImage</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellImage position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>CellImage</class-id><body>CellImage est le grain cellulaire dans le module. Cette classe devrait etre travaillée en fonction des applications viséesInstance Variables:	cellImage	&lt;Image&gt;	image extraite lors de la segmentation	position	&lt;Point&gt;	  position initiale de la cellule dans l'image</body></comment><class><name>UIProjets1</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>laVue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>UIProjets1</class-id><body>UIProjets1 Souche d'application destinée à etre spécialiséeInstance Variables:	laVue	&lt;GrilleImageView&gt;	  laVue présentée</body></comment><class><name>GrilleImageView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interCellOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>GrilleImageView</class-id><body>GrilleImageView on y affiche l'image segmentée, ou non segmentéeInstance Variables:	interCellOffset	&lt;Point&gt;	intestice entre les images élémentaires 1@1 par défaut</body></comment><class><name>GrilleImage</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>imageFileName cellSize cellArray image </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Projets2018</package></attributes></class><comment><class-id>GrilleImage</class-id><body>GrilleImage est le modele initial pour l'applicationInstance Variables:	cellArray	&lt;Array of: Array of: CellImage&gt;	description of cellArray	cellSize	&lt;Point&gt;	dimension de la cellule	image	&lt; Image&gt;	  image initiale complete	imageFileName	&lt;String&gt;	nom du fichier exterieur si il existe</body></comment><methods><class-id>CellImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="cellImage:position:">cellImage: image position: position	^(self new)		cellImage: image;		position: position</body></methods><methods><class-id>CellImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface opening</category><body package="Projets2018" selector="open">open	| interface |	interface := self basicNew initialize.	interface isNil ifFalse: [interface open]</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface opening</category><body package="Projets2018" selector="openFrom:">openFrom: fileName	| interface |	interface := self basicNew.	interface initializeFrom: fileName.	interface open</body></methods><methods><class-id>UIProjets1 class</class-id> <category>interface specs</category><body package="Projets2018" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'kit Project' 			#bounds: #(#{Graphics.Rectangle} 792 318 1233 730 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 4 0 435 0 408 0 ) 					#name: #ViewHolder1 					#component: #laVue ) ) ) )</body></methods><methods><class-id>UIProjets1 class</class-id> <category>resources</category><body package="Projets2018" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Save' ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Edit' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Intersise' 							#value: #doIntestice ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>GrilleImageView class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	^self basicNew initialize</body></methods><methods><class-id>GrilleImage class</class-id> <category>testing</category><body package="Projets2018" selector="testCreateDialog">testCreateDialog	" self testCreateDialog "	^self fromFile</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromFile">fromFile	| file reader gimage fileName |	fileName := Dialog requestFileName: 'Choisir une image'.	fileName isEmpty		ifTrue: [^nil]		ifFalse: 			[file := fileName asFilename.			file exists				ifTrue: 					[reader := ImageReader fromFile: file.					gimage := self new.					gimage imageFileName: fileName.					gimage image: reader image.					gimage setUpGrid.					^gimage]]</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="new">new	^self basicNew initialize.</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromUser">fromUser	| gimage fileName image |	fileName := 'fromUser'.	image := Image fromUser.	gimage := self new.	gimage imageFileName: fileName.	gimage image: image.	gimage setUpGrid.	^gimage</body></methods><methods><class-id>GrilleImage class</class-id> <category>testing</category><body package="Projets2018" selector="testCreate">testCreate	^self fromFile: 'xxx.png'</body></methods><methods><class-id>GrilleImage class</class-id> <category>instance creation</category><body package="Projets2018" selector="fromFile:">fromFile: fileName	| file reader gimage |	file := fileName asFilename.	file exists		ifTrue: 			[reader := ImageReader fromFile: file.			gimage := self new.			gimage imageFileName: fileName.			gimage image: reader image.			gimage setUpGrid.			^gimage]		ifFalse: 			[Dialog warn: 'cannot find ' , fileName.			gimage := self new.			gimage imageFileName: nil.			gimage image: nil.			^gimage]</body></methods><methods><class-id>CellImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	cellImage := nil.	position := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellImage">cellImage	^cellImage</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="position:">position: anObject	position := anObject</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="position">position	^position</body></methods><methods><class-id>CellImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellImage:">cellImage: anObject	cellImage := anObject</body></methods><methods><class-id>UIProjets1</class-id> <category>accessing</category><body package="Projets2018" selector="laVue">laVue	^laVue</body></methods><methods><class-id>UIProjets1</class-id> <category>accessing</category><body package="Projets2018" selector="laVue:">laVue: anObject	laVue := anObject</body></methods><methods><class-id>UIProjets1</class-id> <category>initialize-release</category><body package="Projets2018" selector="initializeFrom:">initializeFrom: fileName	| monModele |	monModele := (GrilleImage fromFile: fileName) asValue.	laVue := GrilleImageView new.	laVue interCellOffset: 1 @ 1.	laVue model: monModele</body></methods><methods><class-id>UIProjets1</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	| monModele choice |	choice := Dialog				choose: 'Choisir une image:'				labels: (Array with: 'from user' with: 'from a file' with: 'xxx.png')				values: #(#fromUser #testCreateDialog #testCreate)				default: #testCreateDialog.	choice isEmpty		ifTrue: [^nil]		ifFalse: 			[monModele := (GrilleImage perform: choice) asValue.			laVue := GrilleImageView new.			laVue interCellOffset: 1 @ 1.			laVue model: monModele.			self]</body></methods><methods><class-id>UIProjets1</class-id> <category>actions</category><body package="Projets2018" selector="doRandomPoint">doRandomPoint	| grille randPoint |	grille := self laVue value.	randPoint:=grille randomCell.	Dialog warn: randPoint printString</body></methods><methods><class-id>UIProjets1</class-id> <category>actions</category><body package="Projets2018" selector="doIntestice">doIntestice	| interCell choix rs x y |	interCell := self laVue interCellOffset.	choix := Dialog request: 'interstice?' initialAnswer: interCell printString.	choix isEmpty		ifFalse: 			[rs := choix readStream.			x := (rs upTo: $@) asNumber.			y := rs upToEnd asNumber.			self laVue interCellOffset: (x @ y) .			self laVue model value: self laVue model value]</body></methods><methods><class-id>GrilleImageView</class-id> <category>accessing</category><body package="Projets2018" selector="interCellOffset">interCellOffset	^interCellOffset</body></methods><methods><class-id>GrilleImageView</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self interCellOffset: 0@0.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>GrilleImageView</class-id> <category>accessing</category><body package="Projets2018" selector="interCellOffset:">interCellOffset: anObject	interCellOffset := anObject</body></methods><methods><class-id>GrilleImageView</class-id> <category>displaying</category><body package="Projets2018" selector="displayOn:">displayOn: aGC	| grille cellSize offset yPos xPos |	grille := self model value cellArray.	grille isNil ifTrue: [ ^  nil].	cellSize := self model value cellSize.	offset := cellSize + self interCellOffset.	yPos := 0.	grille do: 			[:line |			xPos := 0.			line do: 					[:cell |					cell cellImage displayOn: aGC at: xPos @ yPos.					xPos := xPos + offset x].			yPos := yPos + offset y]</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="imageFileName">imageFileName	^imageFileName</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellArray">cellArray	^cellArray</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellArray:">cellArray: anObject	cellArray := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="image">image	^image</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellSize:">cellSize: anObject	cellSize := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="setupFromInage">setupFromInage	  	| xDim yDim |	cellSize := 10@10.	xDim := (self image width / cellSize x ) + 1.	yDim := (self image height / cellSize y ) + 1.	cellArray := ( 1 to: yDim) collect: [ :rowIndex | (1 to: xDim) asArray].	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	imageFileName := nil.	cellSize := 10@10.	cellArray := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="imageFileName:">imageFileName: anObject	imageFileName := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="cellSize">cellSize	^cellSize</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="image:">image: anObject	image := anObject</body></methods><methods><class-id>GrilleImage</class-id> <category>initialize-release</category><body package="Projets2018" selector="setupEmpty">setupEmpty	  	| xDim yDim |	cellSize := 10@10.	xDim := (self image width / cellSize x ) + 1.	yDim := (self image height / cellSize y ) + 1.	cellArray := ( 1 to: yDim) collect: [ :row | (1 to: xDim) asArray].	^self</body></methods><methods><class-id>GrilleImage</class-id> <category>converting</category><body package="Projets2018" selector="setUpGrid">setUpGrid	| bounds nbLines nbCol wsLines yIndex xIndex wsCols newImage thisImage cellImage |	self image isNil ifTrue: [^false].	bounds := self image bounds.	nbLines := ((1 + bounds height) / self cellSize y) truncated.	nbCol := ((1 + bounds width) / cellSize x) truncated.	wsLines := (Array new: nbLines) writeStream.	yIndex := 0.	nbLines timesRepeat: 			[xIndex := 0.			wsCols := (Array new: nbCol) writeStream.			nbCol timesRepeat: 					[newImage := Image								extent: self cellSize								depth: image depth								bitsPerPixel: image bitsPerPixel								palette: image palette copy.					thisImage := newImage								copy: (0 @ 0 extent: self cellSize)								from: xIndex @ yIndex								in: image								rule: RasterOp paint.					cellImage := CellImage cellImage: thisImage position: xIndex @ yIndex.					wsCols nextPut: cellImage.					xIndex := xIndex + self cellSize x].			wsLines nextPut: wsCols contents.			yIndex := yIndex + self cellSize y].	self cellArray: wsLines contents</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="width">width^self cellArray first size.</body></methods><methods><class-id>GrilleImage</class-id> <category>accessing</category><body package="Projets2018" selector="height">height^self cellArray size.</body></methods><methods><class-id>GrilleImage</class-id> <category>utilities</category><body package="Projets2018" selector="randomCell">randomCell| rand rx ry |	rand := Random new.rx:= (rand * self width ) truncated + 1.ry:= (rand * self height ) truncated + 1.^rx@ry</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="Projets2018" selector="menuItemProject">menuItemProject	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openProject		label: #(#_Project #menus '&amp;Project')		icon: #(#{UI.ResourceRetriever} #{WorkspaceIcons} #workspace)		nameKey: nil		menu: #(#menuBar #tools)		position: 11.1&gt;		self openApplicationForClassNamed: #UIProjets1</body></methods><pundle-loaded><name>Projets2018</name><type>package</type><primaryKey>4</primaryKey><databaseId>#student2018</databaseId></pundle-loaded><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/INCASE/INCASE.im' 'April 5, 2018' '8:21:33 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/INCASE/INCASE.im was created at 8:21:33 AM on April 5, 2018."</do-it><component-created><name>Snake</name> <type>package</type></component-created><component-property><name>Snake</name> <type>package</type><property>comment</property> <value>'Snake game - OOP Project - L2 2018'</value></component-property><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><comment><class-id>SnakeUI</class-id><body>SnakeUI is the application model for our Snake game</body></comment><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 35 151 907 613 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 244 113 1044 643 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 500 0 500 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><do-it>SnakeUI organization addCategory: #accessing</do-it><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground">playground	^playground</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground:">playground: anObject	playground := anObject</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="playground">playground	^playground</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Snake class</class-id> <category>instance creation</category><body package="Snake" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeController</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><class><name>SnakeView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeView</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>SnakeView organization addCategory: #'controller accessing'</do-it><methods><class-id>SnakeView</class-id> <category>controller accessing</category><body package="Snake" selector="defaultControllerClass">defaultControllerClass	^SnakeController</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		playground := SnakeView new</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><do-it>Snake organization addCategory: #accessing</do-it><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="board">board	^board</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="board:">board: anObject	board := anObject</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="position">position	^position</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="position:">position: anObject	position := anObject</body></methods><do-it>Snake class organization addCategory: #testing</do-it><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard""</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: (Array new: 300). "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: (Array new: 300). "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><do-it>	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</do-it><do-it>SnakeView organization addCategory: #displaying</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board |	board :=self model value. "On recupere le modele du controlleur" </body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"	</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixel :=Rectangle origin: 0@0 corner: 5@5. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |				]		]			</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"				]		]			</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im' 'April 5, 2018' '9:57:54 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im was created at 9:57:54 AM on April 5, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im' 'April 5, 2018' '9:58:21 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake2/Snake2.im was created at 9:58:21 AM on April 5, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"	"	0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					trouver comment afficher le carre				]		]"		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		0 to: (board size) do: 		[ :line | 			0 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"									]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asStroker.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new	</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new.	playground model: board.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 200.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@(-10) corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: line @ column				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: 50 @ 70				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: 50 @ 70				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos				].			xpos := xpos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><do-it>SnakeUI organization addCategory: #changing</do-it><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	| board|	board := self playground model value.	self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	playground := SnakeView new.	playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		| board  |	board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 500.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.					pixel asFiller displayOn: aGC.					xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		pixel asFiller displayOn: aGC.		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + 50.				].			ypos := ypos + 50.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 1.	1 to: (board size) do: 		[ :line | 			xpos := 1.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		"pixel asFiller displayOn: aGC."		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					gaw := GraphicsAttributesWrapper on: pixel asFiller.					ga := GraphicsAttributes new paint: ColorValue black.					gaw attributes: ga.					gaw displayOn: aGC at: xpos @ ypos.										xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel ga gaw xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel  xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"		ypos := 0.	1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>controller accessing</category><body package="Snake" selector="defaultControllerClass">defaultControllerClass	^Snake</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		 1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.				]		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		xpos := position x.	ypos := position y.	 1 to: (board size) do: 		[ :line | 			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: position.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '2:17:35 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 2:17:35 PM on April 21, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos := position y.	 1 to: (board size) do: 		[ :line | 			xpos := position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	"position := board position. starting position of the board defined in Snake"			ypos := board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"			ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel position xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	" position := board position. starting position of the board defined in Snake"	board inspect.	ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	" position := board position. starting position of the board defined in Snake"	board inspect.	ypos :=0.	 1 to: (board size) do: 		[ :line | 			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		pixel asFiller displayOn: aGC at: 5@5.		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"	position := board position. "starting position of the board defined in Snake"		pixel asFiller displayOn: aGC at: 5@5.		ypos :=board position y.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := board position x.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos position|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.				ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	(board size) inspect.		ypos := 0.	 1 to: (board size) do: 		[ :line | 			line inspect.			xpos := 0.			1 to: ((board at: line) size) do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="width">width	^width</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="width:">width: anObject	width := anObject</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="height">height	^height</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="height:">height: anObject	height := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board board width: 300.	board board height: 500.	board position: 30 @ 30.	^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	width := board width.	height := board height.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	width := 300.	height := 500.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.		board inspect.	ypos := 0.	 1 to: 500 do: 		[ :line | 			line inspect.			xpos := 0.			1 to: 300 do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>width</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>width</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>height</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>height</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board position: 30 @ 30.	^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 500) collect: [ :element | Array new: 300 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board width: 300.	board height: 500.	board position: 30 @ 30.	^board</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			line inspect.			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asFiller displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: 0@0.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 88 73 1240 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 730 0 630 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 88 73 1240 731 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 730 0 630 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:02:31 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:02:31 PM on April 21, 2018."</do-it><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ]. "matrix of 500 lines and 300 columns"	board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.	^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		pixel asFiller displayOn: aGC at: height@width.	board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: (height*5)@(width*5).	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 0 0 800 0 700 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 0 0 800 0 700 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 731 0 631 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) ) ) )</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"trouver comment afficher le carre"					pixel asStroker displayOn: aGC at: xpos@ypos.					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].			board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(playground at: 1) do: [:col | (playground at:1) at: col put: -1  ].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	"(playground at: 1) do: [:col | (playground at:1) at: col put: -1  ]."		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(playground at: 1) do: [:col | (playground at:1) at: col put: 0 ].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					(column isNil) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					( (board board at: line) at: column isNil) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						pixel asFiller displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						pixel asFiller displayOn: aGC at: xpos@ypos.					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						pixel asStroker displayOn: aGC at: xpos@ypos.					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.	pixel asFiller displayOn: aGC at: height@width.	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:00 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:00 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:00 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:00 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:45:01 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:45:01 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 21, 2018' '3:59:43 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:59:43 PM on April 21, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '2:16:09 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 2:16:09 PM on April 23, 2018."</do-it><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board position width height snake </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="snake">snake	^snake</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="snake:">snake: anObject	snake := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	(1 to: 3) do: [ :i | snake add: i].		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( ((board board at: line) at: column)).					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 0@0.	snake add: 1@0.	snake add: 2@0.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue blue.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue green.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].									( board snake includes: xpos@ypos) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue blue.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		]</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@0.	snake add: 51@0.	snake add: 52@0.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@20.	snake add: 51@20.	snake add: 52@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		(Rectangle origin: 100@100 corner: pixelWidth@pixelWidth) displayFilledOn: aGC.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"			board inspect.		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		board position: 30 @ 30.		^board</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>position</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>position</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><remove-selector><class-id>Snake</class-id> <selector>position:</selector></remove-selector><remove-selector><class-id>Snake</class-id> <selector>position</selector></remove-selector><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.		^board</body></methods><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground play </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="play">play	^play</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake" selector="play:">play: anObject	play := anObject</body></methods><do-it>SnakeUI organization addCategory: #actions</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board |	board := self playground model value.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake |	board := self playground model value.	snake := board snake.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake |	board := self playground model value.	snake := board snake.		</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="direction">direction	^direction</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="direction:">direction: anObject	direction := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 15.		^board</body></methods><comment><class-id>Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of board	direction	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	gives direction of snake : 0 -&gt; up ; 15 -&gt; right ; 30 -&gt; down ; 45 -&gt; left	height	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of height	snake	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snake	width	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of width</body></comment><comment><class-id>Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of board	direction	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	gives direction of snake : 0 -&gt; up ; 1 -&gt; right ; 2 -&gt; down ; 3 -&gt; left	height	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of height	snake	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snake	width	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of width</body></comment><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@20.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	snake := board direction.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[				].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[		snake do: []		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[		snake do: [ :pos | ]		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(direction = 0) ifTrue:[			(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)].		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[					].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ]. </body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction |	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ].		^gameOver </body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing	| delay gameOver |	self		processMove: 			[delay := Delay forMilliseconds: 100.			[true] whileTrue: 					[delay wait.					self move.]]					fork.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="playing">playing	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]</body></methods><remove-selector><class-id>SnakeUI</class-id> <selector>playing</selector></remove-selector><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:36:17 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:36:17 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 100.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:37:03 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:37:03 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.				gameOver inspect.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #ActionButton1 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		(self builder componentAt: #StartButton) disable.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.		(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:39:56 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:39:56 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>SnakeUI organization addCategory: #changing</do-it><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="changeBoard">changeBoard	self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.		board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 10000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 23, 2018' '3:57:31 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:57:31 PM on April 23, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. "doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	snake add: 25@25.		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head"			(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board tmp snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	tmp := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ tmp add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ tmp add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ tmp add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ tmp add: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: snake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].				"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(direction = 0) ifTrue:[ newSnake add: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake add: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake add: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake add: (snake first x - 5)@(snake first y) ].		(2 to: snake size) do: [ :i | newSnake add: (snake at: i) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction gameOver |		gameOver := false.	" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.		^gameOver</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 1000.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay gameOver |	self play: [		delay := Delay forMilliseconds: 10.		gameOver := false.		[ gameOver = false ] whileTrue: 		[delay wait.		gameOver := self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 10.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '1:54:15 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:54:15 PM on April 24, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '1:54:25 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:54:25 PM on April 24, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 24, 2018' '5:13:02 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 5:13:02 PM on April 24, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := board snake.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := board snake asValue.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board snake |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	snake := Snake testBoard snake asValue.	snake onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: GAMEOVER ]."		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardY) at: boardX = -1) ifTrue: [ Transcript show: 'GAMEOVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardY) at: boardX = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	boardY inspect.	boardX inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := (snake first y) / 5.	boardX := (snake first x) / 5.	boardY inspect.	boardX inspect.	snake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	snake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction  "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect."	boardY := ((snake first y) / 5) asInteger.	boardX := ((snake first x) / 5) asInteger.	boardY inspect.	boardX inspect.	newSnake inspect.	((board at: boardX) at: boardY = -1) ifTrue: [ snake inspect ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 79 47 1231 705 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcessus">killProcessus</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "</body></methods><remove-selector><class-id>SnakeUI</class-id> <selector>killProcessus</selector></remove-selector><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.	</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		self play terminate.	(self builder componentAt: #startButton) enable</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:24:52 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:24:52 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		newSnake inspect.		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:38:34 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:38:34 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:39:50 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:39:50 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect.	"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '9:41:30 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 9:41:30 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].	newSnake inspect.	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	newSnake inspect.	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardY) at: boardX) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect.	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 1000.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay |	self play: [		delay := Delay forMilliseconds: 10000.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@21.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 50@25.	snake add: 55@20.	snake add: 60@20.	snake add: 65@20.	snake add: 70@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.	snake add: 60@20.	snake add: 55@20.	snake add: 50@25.						board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	"boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	"boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"boardX := (snake first x) / 5.	boardY := (snake first y) / 5.	boardX inspect.	boardY inspect.	newSnake inspect."	"((board at: boardX) at: boardY) ifTrue: [ Transcript show: 'GAME OVER' ]."		snake inspect.		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction |		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].	"((board at: (snake first y)) at: (snake first x) = -1) ifTrue: [ gameOver := true ]."	board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: boardX) at: boardY = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '10:02:19 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 10:02:19 AM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 12) at: 4 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: boardX) at: boardY = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 0) at: 0 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	board := self playground model value.	snake := board snake.	newSnake := OrderedCollection new.	direction := board direction.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 10) at: 10 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) at: 1 = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ]."		board snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ]."		model snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		board inspect.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((board at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction tmp "boardX boardY"|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			"boardX := snake first x / 5.	boardY := snake first y / 5."	tmp := board at: 1.	tmp inspect.	((tmp at: 1) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	wallCheck inspect.	((wallCheck at: boardY) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	((wallCheck at: boardY) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ Transcript show: 'We reached a wall' ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ SnakeUI killProcess ].		model snake: newSnake.	self playground model value: model.</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction gameover </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="gameover">gameover	^gameover</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="gameover:">gameover: anObject	gameover := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board gameover: true.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) ifTrue: [ model gameover: true ].		model snake: newSnake.	self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(gameover) ifTrue: [].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [	self play terminate.	(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	model gameover: true.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board gameover: false.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	model := self playground model value.	model gameover: false.	self play: [		delay := Delay forMilliseconds: 200.		[model gameover = false] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.	(model gameover) ifTrue: [			self play terminate.		(self builder componentAt: #startButton) enable].</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ model gameover: true ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.	board gameover: false.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].			self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	self play terminate.	(self builder componentAt: #startButton) enable</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>gameover</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>gameover</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><remove-selector><class-id>Snake</class-id> <selector>gameover</selector></remove-selector><remove-selector><class-id>Snake</class-id> <selector>gameover:</selector></remove-selector><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 0.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	self play terminate.	self initialize.	(self builder componentAt: #startButton) enable</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	" for means of testing "		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.	Transcript show: 'post terminate message in killProcess'</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.	Transcript show: 'post terminate message in killProcess'</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self initialize.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self initialize.	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	self initialize.	Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"		Transcript show: 'process killed'.	(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self initialize.	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 200.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '10:59:20 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 10:59:20 AM on April 26, 2018."</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	(event = #keyDown) ifTrue: [ self direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ self direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 1]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board. 	</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="changeDirection:">changeDirection: event	|  board |	board := self model value.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>changeDirection:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event	(event ) ifTrue: [ ]  </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent eventType.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent eventType.	Transcript show: key printString.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyPressedEvent .	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := KeyboardEvent isKeyPress .	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := 'event !'.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := 'event !'.	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>keyPressedEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboardPressed	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboardPressed			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	self sensor keyboard digitValue.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	key := self sensor keyboard digitValue.	Transcript show: key printString.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event		| key |	 self sensor cursorPointFor: event.	Transcript show:'hi'.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 self sensor cursorPointFor: event.	Transcript show:'hi'.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="controlActivity">controlActivity</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>controlActivity</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 "self sensor cursorPointFor: event.	Transcript show:'hi'."	| key |	key := self processKeyboardEvent: event.	key inspect.			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyboardEvent:">keyboardEvent: event			 "self sensor cursorPointFor: event.	Transcript show:'hi'."	| key |	key := self KeyPressedEvent isKeyPress.	(key = true)			"|  board key |	board := self model value.	key := event keyboard digitValue.	key inspect.	(event = #keyDown) ifTrue: [ board direction: 0].	(event = #keyUp) ifTrue: [ board direction: 2].	(event = #keyRight) ifTrue: [ board direction: 1].	(event = #keyLeft) ifTrue: [ board direction: 3].		self model value: board."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	| key |	key := self sensor eventKeyPress: event.	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseMovedEvent:">mouseMovedEvent: event	Transcript show: 'Does it work ?'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>keyboardEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="keyPressedEvent:">keyPressedEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseMovedEvent:">mouseMovedEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseButtonRelease:">mouseButtonRelease: event	Transcript show: 'Working'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="mouseButtonReleaseEvent:">mouseButtonReleaseEvent: event	Transcript show: 'Working'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>mouseButtonReleaseEvent:</selector></remove-selector><remove-selector><class-id>SnakeController</class-id> <selector>mouseButtonRelease:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="processKeyboardEvent:">processKeyboardEvent: event	Transcript show: 'A key has been pressed'</body></methods><remove-selector><class-id>SnakeController</class-id> <selector>processKeyboardEvent:</selector></remove-selector><remove-selector><class-id>SnakeController</class-id> <selector>keyPressedEvent:</selector></remove-selector><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	Transcript show: 'A key has been pressed'</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keypress.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor digitValue.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keyboard digitValue.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := self sensor keyboard digitValue.	"Transcript show: key printString."</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	Transcript show: event printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	key := event keyCharacter.	Transcript show: key printString.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event keyCharacter.	key inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event keyCharacter.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	key := event eventType.	key inspect.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		"key := self sensor keyboard digitValue."	event inspect.	event keyValue inspect.	</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key |		key := event keyValue inspect.	(key = #Down) ifTrue: [ ]</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board |		board := self model value.	key := event keyValue inspect.	(key = #Down) ifTrue: [ ]</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newDrection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><do-it>SnakeController addInstVarName: 'newDrection'</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDrection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1]. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key = #Down) ifTrue: [ newDirection := 0 ].	(key = #Up) ifTrue: [ newDirection := 2 ].	(key = #Left) ifTrue: [ newDirection := 3 ].	(key = #Right) ifTrue: [ newDirection := 1].		self model value: board. </body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue inspect.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		self model value: board.</body></methods><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		newDirection inspect.		self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down) ifTrue: [ newDirection := 0 ].	(key == #Up) ifTrue: [ newDirection := 2 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:37:06 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:37:06 PM on April 26, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:37:12 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:37:12 PM on April 26, 2018."</do-it><remove-selector><class-id>SnakeController</class-id> <selector>mouseMovedEvent:</selector></remove-selector><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '4:38:03 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:38:03 PM on April 26, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 26, 2018' '5:44:11 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 5:44:11 PM on April 26, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 20.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"			(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"			|  board |		board := Snake testBoard asValue.	self playground model: board.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	"resets the game position"		|  board |	board := Snake testBoard asValue.	self playground model: board.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><comment><class-id>SnakeController</class-id><body>SnakeController allows us to control our Snake in the application. It is useful for moving the snake around.</body></comment><comment><class-id>SnakeView</class-id><body>SnakeView allows us to display our game on the UI.ApplicationModel SnakeUI view.</body></comment><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction food </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="food">food	^food</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="food:">food: anObject	food := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |	playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board food: 50@50. 		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	board food: 50@50. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 50@50. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga foodX foodY|	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		foodX := board food x.	foodY := board food y.				</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x / 5.	ypos := board food y / 5.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos			</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 100@100. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.		self playground invalidate</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake.		self changeBoard].		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 27, 2018' '11:25:22 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 11:25:22 AM on April 27, 2018."</do-it><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection &lt;&gt; 1) ) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection ~= 1) ) ifTrue: [ newDirection := 2 ].	(key == #Up) ifTrue: [ newDirection := 0 ].	(key == #Left) ifTrue: [ newDirection := 3 ].	(key == #Right) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake" selector="anyfocusKeypressEvent:">anyfocusKeypressEvent: event	"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		board := self model value.	newDirection := board direction.	key := event keyValue	.	(key == #Down &amp; (newDirection ~= 0) ) ifTrue: [ newDirection := 2 ].	(key == #Up &amp; (newDirection ~= 2) ) ifTrue: [ newDirection := 0 ].	(key == #Left &amp; (newDirection ~= 1) ) ifTrue: [ newDirection := 3 ].	(key == #Right &amp; (newDirection ~= 3) ) ifTrue: [ newDirection := 1].		board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		" REPRENDRE IL Y A DES ERREURS"	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.		"(2 to: snake size) reverseDo: [ :i | snake at: i put: (snake at: i - 1)]. doesn't depend on direction	is just making sure the body follows the head		(direction = 0) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ snake at: 1 put: (snake first x + 5)@(snake first y) ].	(direction = 2) ifTrue:[ snake at: 1 put: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ snake at: 1 put: (snake first x - 5)@(snake first y) ]."		(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ model food: 90@90 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ model food: 300@300 ].		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 300@300. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ model food: 300@300. Transcript show: 'I ate it !' ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first x = food x) ifTrue: [ model food: 300@300. Transcript show: 'I ate it !' ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first x = food x) ifTrue: [ model food: 900@900. Transcript show: 'I ate it !' ].		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 70@20. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY|		model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ model food: 900@900. Transcript show: 'I ate it !' ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: 		[  rand := Random new.		 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand * model width) truncated.		foodY := (rand next * model height) truncated.		model food: foodX @ foodY.				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand * (model width)) truncated.		foodY := ((rand next )* (model height)) truncated.		model food: foodX @ foodY.				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand * 80) truncated.		foodY := ((rand next )* 80) truncated.		model food: foodX @ foodY.				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand next * 80) truncated.		foodY := ((rand next )* 80) truncated.		model food: foodX @ foodY.				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand next * model width) truncated.		foodY := (rand next * model height) truncated.		model food: (foodX * 5) @ (foodY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.		foodX := (rand next * model width) truncated.		foodY := (rand next * model height) truncated.				model food: (foodX * 5) @ (foodY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 				rand := Random new.		foodX := (rand next * model width) truncated.		foodY := (rand next * model height) truncated.				model food: (foodX * 5) @ (foodY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand foodX foodY|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				foodX := (rand next * model width) truncated.		foodY := (rand next * model height) truncated.								model food: (foodX * 5) @ (foodY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.								model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		wallCheck := board at: boardY.				[ ]				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := 				wallCheck := board at: boardY.				[ ]				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := true.				wallCheck := board at: boardY.				[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:		[].				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := true.				wallCheck := board at: boardY.				[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:		[			boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.		].				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := true.		wallCheck := board at: boardY.				[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:		[			boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.								].				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := true.		wallCheck := board at: boardY.				[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:		[			snakeCheck := false.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.						newSnake do: [ :pos | (pos = (boardX * 5)@(boardY *5)) ifTrue: [ snakeCheck := true ] ]		].				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 		rand := Random new.				boardX := (rand next * model width) truncated.		boardY := (rand next * model height) truncated.		"we are checking if nothing already exists where we want the food to reappear"		snakeCheck := true.		wallCheck := board at: boardY.				[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:		[			snakeCheck := false.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking that the position of the food isn't one of the snake"			newSnake do: [ :pos | (pos = (boardX * 5)@(boardY *5)) ifTrue: [ snakeCheck := true ] ]		].				model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = (boardX * 5)@(boardY *5)) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (board * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ]	ifFalse: [ model snake: newSnake].		(newSnake first = food) ifTrue: [ 			"snake grows"									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"snake grows"			(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].			(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].			(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].			(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 80) do: [ :i | (playground at: 60) at: i put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 80) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 80) do: [ :i | (playground at: i) at: 50 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 80) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 80) do: [ :i | (playground at: i) at: 50 put: -1].	(30 to: 80) do: [ :i | (playground at: i) at: 60 put: -1].		"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 80) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 80) do: [ :i | (playground at: i) at: 50 put: -1].	(30 to: 80) do: [ :i | (playground at: i) at: 60 put: -1].			"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 3) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 5) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(30 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 27, 2018' '1:36:34 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:36:34 PM on April 27, 2018."</do-it><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(60 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(50 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(30 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(900 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(1 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 80) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 120) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(30 to: 90) do: [ :i | (playground at: 60) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(50 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(60 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 30 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1].				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."				"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.		^board</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 635 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 783 0 107 0 883 0 132 0 ) 					#name: #score 					#model: #score ) ) ) )</body></methods><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground play score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><do-it>Smalltalk defineClass: #SnakeUI	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'playground play  score '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>SnakeUI</class-id> <category>aspects</category><body package="Snake" selector="score">score	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^score isNil		ifTrue:			[score := String new asValue]		ifFalse:			[score]</body></methods><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction food score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="score">score	^score</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake" selector="score:">score: anObject	score := anObject</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos		</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore	|  |	score := self perform: #score.	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore	| scoreField |	scoreField := self perform: #score.	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore	| scoreField model |	model := self playground value.	scoreField := self perform: #score.	scoreField value: model score printString.	</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake" selector="updateScore">updateScore	| scoreField model |	model := self playground model value.	scoreField := self perform: #score.	scoreField value: model score printString.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 27, 2018' '3:56:28 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 3:56:28 PM on April 27, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  scoreField |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	scoreField := self perform: #score.	scoreField := board score.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  scoreField |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand |	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"										"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board score onChangeSend: #updateScore to: self.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake" selector="initialize">initialize		|  board  |		board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	board onChangeSend: #updateScore to: self.	board onChangeSend: #changeBoard to: self</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	self updateScore.	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"we do not initialize score here as we want to keep it until we start a new game"		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay  |	"we update the score here in order to save the score after we loose"	self updateScore.	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	"we update the score here in order to save the score after we loose"	self updateScore.	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	"we update the score here in order to save the score after we loose"	model := self playground value.	model score: 0.	self updateScore.	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="startPlaying">startPlaying	| delay model |	"we update the score here in order to save the score after we loose"	model := self playground model value.	model score: 0.	self updateScore.	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	"resets the game position"		|  board |	board := Snake testBoard asValue.	(self playground model: board) inspect.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150. 	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="killProcess">killProcess	"kills the process ;	warning : everything post terminate message will not work"	"resets the game position"		|  board |	board := Snake testBoard asValue.	self playground model: board.		(self builder componentAt: #startButton) enable.	self play terminate.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	((wallCheck at: boardY) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardX.						[ ((wallCheck at: boardY) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next + 1 * model width) truncated.			boardY := (rand next + 1 * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 27, 2018' '4:28:18 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 4:28:18 PM on April 27, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: 1) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.				Transcript show: 'loop'.				boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardX.						[ ((wallCheck at: boardY) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardX.	((wallCheck at: boardY) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardX.						[ ((wallCheck at: boardY) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 29, 2018' '8:20:35 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 8:20:35 PM on April 29, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardX.						[ ((wallCheck at: boardY) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			boardX inspect.			boardY inspect.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	"board food: 150@150. "	board food: 5@500.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asStroker.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake" selector="displayOn:">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |	board :=self model value. "On recupere le modele du controlleur" 	pixelWidth := 5.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. "pixel size is 5 by 5"		height := board height.	width := board width.		ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column |					"condition pour sol normal"					( ((board board at: line) at: column) isNil ) ifTrue: [						"trouver comment afficher le carre"						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					"condition pour mur"					( ((board board at: line) at: column)  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue red.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos					].					xpos := xpos + pixelWidth.				].			ypos := ypos + pixelWidth.		].		( board snake) do: 		[ :coords | 			gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords		].		xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	"board food: 150@150. "	board food: 500@5.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	"board food: 150@150. "	board food: 500@0.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><do-it>|rand col|rand := Random new.col := (1 to: 100) collect: [ :i  | (rand next *  140) truncated ].col inspect</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.				"we are checking that the position of the food isn't one of the snake"				wallCheck := board at: boardY.				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := snake first x / 5.	boardY := snake first y / 5.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := (rand next * model width) truncated.			boardY := (rand next * model height) truncated.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	"board food: 150@150. "	board food: 150@150.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	board score: 0.		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><do-it>|rand col|rand := Random new.col := (1 to: 100) collect: [:i | (rand next * 120) truncated].col inspect</do-it><do-it>|rand col|rand := Random new.col := (1 to: 100) collect: [:i | (rand next * 120) truncated].col asSortedCollection inspect</do-it><do-it>|rand col|rand := Random new.col := (1 to: 1000) collect: [:i | (rand next * 120) truncated].col asSortedCollection inspect</do-it><do-it>|rand col|rand := Random new.col := (1 to: 10000) collect: [:i | (rand next * 120) truncated].col asSortedCollection inspect</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := ((rand next * model width) truncated) asInteger.			boardY := ((rand next * model height) truncated) asInteger.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := (rand next * model width) truncated.				boardY := (rand next * model height) truncated.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 620@150.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@620.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@615.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@600.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@595.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 107 55 1259 713 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 640 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 855 0 60 0 907 0 81 0 ) 					#name: #killProcess 					#model: #killProcess 					#label: 'KILL' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 783 0 107 0 883 0 132 0 ) 					#name: #score 					#model: #score ) ) ) )</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.						boardX := ((rand next * model width) truncated) asInteger.			boardY := ((rand next * model height) truncated) asInteger.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								boardX := ((rand next * model width) truncated) asInteger.				boardY := ((rand next * model height) truncated) asInteger.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := board at: boardY.	((wallCheck at: boardX) = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"explanation for the + 5 :				when converting from @ to tab value the problem is that there is a 5 that differs :				tab -&gt; @				1 -&gt; 0 instead of 5				120 -&gt; 595 instead of 600"				boardX := ((rand next * model width) truncated) asInteger + 5.				boardY := ((rand next * model height) truncated) asInteger + 5.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 0@595.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: (5*139)@595.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.		board := self new.	"position of the food"	board food: 150@150.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := board at: boardY.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"explanation for the + 5 :				when converting from @ to tab value the problem is that there is a 5 that differs :				tab -&gt; @				1 -&gt; 0 instead of 5				120 -&gt; 595 instead of 600"				boardX := ((rand next * model width) truncated) asInteger + 5.				boardY := ((rand next * model height) truncated) asInteger + 5.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := (board at: boardY) at: boardX.						[ ((wallCheck at: boardX) = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"explanation for the + 5 :				when converting from @ to tab value the problem is that there is a 5 that differs :				tab -&gt; @				1 -&gt; 0 instead of 5				120 -&gt; 595 instead of 600"				boardX := ((rand next * model width) truncated) asInteger + 5.				boardY := ((rand next * model height) truncated) asInteger + 5.								wallCheck := board at: boardY.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"explanation for the + 5 :				when converting from @ to tab value the problem is that there is a 5 that differs :				tab -&gt; @				1 -&gt; 0 instead of 5				120 -&gt; 595 instead of 600"				boardX := ((rand next * model width) truncated) asInteger + 5.				boardY := ((rand next * model height) truncated) asInteger + 5.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"explanation for the + 1 :				when converting from @ to tab value the problem is that there is a 5 that differs :				tab -&gt; @				1 -&gt; 0 instead of 5				120 -&gt; 595 instead of 600"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				(boardX * 5)@(boardY * 5) inspect.			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).				((boardX * 5)@(boardY * 5)) inspect.			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	wallCheck inspect.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	Transcript show: 'valeur de wallCheck : ' ,  wallCheck printString , Character cr , ' position de Snake : ' , (snake first) printString , Character cr , ' position boardX :  ', boardX printString , ' boardY : ' , boardY printString, Character cr, Character cr, Character cr.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	Transcript show: 'valeur de wallCheck : ' ,  wallCheck printString , ' position de Snake : ' , (snake first) printString , ' position boardX :  ', boardX printString , ' boardY : ' , boardY printString , 'NEXT ||  ||  ||  ||  |'.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5)@(boardY *5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5) @ (boardY * 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].		(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].			boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 			"update score"			newScore := newScore + 5.						model score: newScore.								"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].									"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.						[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].						model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].		model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 30, 2018' '11:16:27 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 11:16:27 AM on April 30, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checkiing if snake doesn't bite himself"		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"			"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((snake first) = pos) ifTrue: [ self killProcess ] ].				"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((snake first) = pos) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((snake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake" selector="testBoard">testBoard"creating a matrix that will allow us to display elements"	| playground board  snake |		playground := (Array new: 120) collect: [ :element | Array new: 140 ].	"creating walls coded by -1"	(1 to: 140) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: 140) do: [ :i | (playground at: 120) at: i put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: 120) do: [ :i | (playground at: i) at: 140 put: -1].		"(50 to: 110) do: [ :i | (playground at: 60) at: i put: -1].	(50 to: 110) do: [ :i | (playground at: 80) at: i put: -1].	(30 to: 70) do: [ :i | (playground at: 90) at: i put: -1].	(90 to: 120) do: [ :i | (playground at: 50) at: i put: -1].	(120 to: 140) do: [ :i | (playground at: 10) at: i put: -1].	(1 to: 90) do: [ :i | (playground at: 10) at: i put: -1].		(90 to: 120) do: [ :i | (playground at: i) at: 60 put: -1].	(90 to: 120) do: [ :i | (playground at: i) at: 90 put: -1].	(10 to: 60) do: [ :i | (playground at: i) at: 70 put: -1].	(30 to: 100) do: [ :i | (playground at: i) at: 10 put: -1].	(10 to: 80) do: [ :i | (playground at: i) at: 20 put: -1]."					"be careful : a pixel on the board was defined by a rectangle of five per five actual pixels hence the jump of five pixels"	snake := OrderedCollection new.	snake add: 70@20.	snake add: 65@20.		snake add: 60@20.	snake add: 55@20.	snake add: 50@20.	snake add: 45@20.	snake add: 40@20.	snake add: 35@20.	snake add: 30@20.	snake add: 25@20.	snake add: 20@20.	snake add: 15@20.	snake add: 10@20.		board := self new.	"position of the food"	board food: 150@150.	board board: playground.	board width: 140.	board height: 120.	board snake: snake.	board direction: 1.	"board score: 0."		^board</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((snake first) = (newSnake at: pos)) ifTrue: [ Transcript show: 'I bite myself'. self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((snake first) = (newSnake at: pos)) ifTrue: [ Transcript show: 'I bite myself'. "self killProcess" ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ Transcript show: 'I bite myself'. "self killProcess" ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 30, 2018' '11:30:02 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 11:30:02 AM on April 30, 2018."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 30, 2018' '11:34:37 AM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 11:34:37 AM on April 30, 2018."</do-it><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	Transcript show: 'move is called'.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger.	boardY := (snake first y / 5) asInteger.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	boardX := (snake first x / 5) asInteger + 1.	boardY := (snake first y / 5) asInteger + 1.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake" selector="move">move	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY rand newScore|	model := self playground model value.	snake := model snake.	newSnake := OrderedCollection new.	direction := model direction.	board := model board.	food := model food.	newScore := model score.	"making our new snake"		"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + 5) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + 5)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - 5) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - 5)@(snake first y) ].		"checking if snake doesn't run into any walls"	"reason for +1 explained below in food loop"	boardX := (snake first x / 5) asInteger + 1.	boardY := (snake first y / 5) asInteger + 1.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	(newSnake first = food) ifTrue: [ 					"update score"			newScore := newScore + 5.			model score: newScore.						"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + 5) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + 5)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - 5) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - 5)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * 5) - 5				because if i = 1 then @ = 0				and if i = 120 then @ = 595"				newSnake do: [ :pos | (pos = ((boardX * 5  - 5)@(boardY *5 - 5))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model"			model food: (boardX * 5 - 5) @ (boardY * 5 - 5).			 ].	"giving the model"	model snake: newSnake.		self playground model value: model.</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im' 'April 30, 2018' '1:14:08 PM')""An image file /home/leonard/Documents/Code/SMALLTALK/Projects/Snake/Snake.im was created at 1:14:08 PM on April 30, 2018."</do-it>