<?xml version="1.0"?><st-source><!-- Name: SnakeComment: Snake game - OOP Project - L2 2018PackageName: SnakeParcel: #('Snake')ParcelDirectory: SnakeDate: 11:51:47 AM May 8, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.3 of July 28, 2017 on May 8, 2018 at 11:51:47 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Snake</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board width height snake direction food score pixel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><comment><class-id>Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of board	direction	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	gives direction of snake : 0 -&gt; up ; 1 -&gt; right ; 2 -&gt; down ; 3 -&gt; left	height	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of height	snake	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snake	width	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of width</body></comment><class><name>SnakeController</name><environment>Smalltalk</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><comment><class-id>SnakeController</class-id><body>SnakeController allows us to control our Snake in the application. It is useful for moving the snake around.</body></comment><class><name>SnakeView</name><environment>Smalltalk</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><comment><class-id>SnakeView</class-id><body>SnakeView allows us to display our game on the UI.ApplicationModel SnakeUI view.</body></comment><class><name>SnakeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>playground play score highscores highscoresView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Snake</package></attributes></class><comment><class-id>SnakeUI</class-id><body>SnakeUI is the application model for our Snake game</body></comment><methods><class-id>Snake</class-id> <category>initialize-release</category><body package="Snake">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Snake</class-id> <category>accessing</category><body package="Snake">board	^board</body><body package="Snake">board: anObject	board := anObject</body><body package="Snake">direction	^direction</body><body package="Snake">direction: anObject	direction := anObject</body><body package="Snake">food	^food</body><body package="Snake">food: anObject	food := anObject</body><body package="Snake">height	^height</body><body package="Snake">height: anObject	height := anObject</body><body package="Snake">pixel	^pixel</body><body package="Snake">pixel: anObject	pixel := anObject</body><body package="Snake">score	^score</body><body package="Snake">score: anObject	score := anObject</body><body package="Snake">snake	^snake</body><body package="Snake">snake: anObject	snake := anObject</body><body package="Snake">width	^width</body><body package="Snake">width: anObject	width := anObject</body></methods><methods><class-id>Snake class</class-id> <category>instance creation</category><body package="Snake">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Snake class</class-id> <category>testing</category><body package="Snake">testBoard"initializing the different variables of a Snake object"	| playground board snake |		board := self new.		"giving the width and height"	board width: 70.	board height: 60.		"creating the playground"	playground := (Array new: board height) collect: [ :element | Array new: board width ].	"creating walls coded by -1"	(1 to: board width) do: [ :i | (playground at: 1) at: i put: -1].	(1 to: board width) do: [ :i | (playground at: board height) at: i put: -1].	(1 to: board height) do: [ :i | (playground at: i) at: 1 put: -1].	(1 to: board height) do: [ :i | (playground at: i) at: board width put: -1].	board board: playground.		"giving the pixel of the board"	board pixel: 10.		"creating snake"	snake := OrderedCollection new.	snake add: 70@20.	(1 to: 4) do: [ :i | snake add: (snake first x)-(i*board pixel)@(snake first y)].	board snake: snake.		"position of the food ; make sure it belongs within the height and width previously given"	board food: 30@30.		"giving direction ; 1 means right"	board direction: 1.	"score starts at 0"	board score: 0.		^board</body></methods><methods><class-id>SnakeController</class-id> <category>initialize-release</category><body package="Snake">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>SnakeController</class-id> <category>events</category><body package="Snake">anyfocusKeypressEvent: event"you need to use anyfocus as keyboard events usually requires a focus"	| key board newDirection |		"initializing the variables needed"	board := self model value.	newDirection := board direction.	key := event keyValue	.	"choosing direction depending on pressed key"	(key == #Down &amp; (newDirection ~= 0) ) ifTrue: [ newDirection := 2 ].	(key == #Up &amp; (newDirection ~= 2) ) ifTrue: [ newDirection := 0 ].	(key == #Left &amp; (newDirection ~= 1) ) ifTrue: [ newDirection := 3 ].	(key == #Right &amp; (newDirection ~= 3) ) ifTrue: [ newDirection := 1].		"passing direction and new model"	board direction: newDirection.	self model value: board.</body></methods><methods><class-id>SnakeView</class-id> <category>initialize-release</category><body package="Snake">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>SnakeView</class-id> <category>controller accessing</category><body package="Snake">defaultControllerClass	^SnakeController</body></methods><methods><class-id>SnakeView</class-id> <category>displaying</category><body package="Snake">displayOn: aGC		| board  pixelWidth pixel xpos ypos width height gaw ga |		"controller model : a Snake"	board :=self model value. 	"create a pixel knowing the size of the pixel giving by the board"	pixelWidth := board pixel.	pixel :=Rectangle origin: 0@0 corner: pixelWidth@pixelWidth. 	"recovering the height and width"	height := board height.	width := board width.		"drawing according to the passed down info"	ypos := 0.	 1 to: height do: 		[ :line | 			xpos := 0.			1 to: width do:				[ :column | | value | "value will keep the value needed in the following conditions"					value := (board board at: line) at: column.					"condition for neutral ground represented by nil"					( value isNil ) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue black.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos"						SnakeUI grass displayOn: aGC at: xpos @ ypos."					].					"condition for a wall"					( value  = -1) ifTrue: [						gaw := GraphicsAttributesWrapper on: pixel asFiller.						ga := GraphicsAttributes new paint: ColorValue darkGray.						gaw attributes: ga.						gaw displayOn: aGC at: xpos @ ypos						"SnakeUI wall displayOn: aGC at: xpos@ypos."					].					"incrementing position by pixel size"					xpos := xpos + pixelWidth.				].			"incrementing position by pixel size"			ypos := ypos + pixelWidth.		].		"drawing the snake"	( board snake) do: 		[ :coords | 			"gaw := GraphicsAttributesWrapper on: pixel asFiller.			ga := GraphicsAttributes new paint: ColorValue blue.			gaw attributes: ga.			gaw displayOn: aGC at: coords"			SnakeUI snakeBody displayOn: aGC at: coords.		].		"drawing the head of the snake"	( board direction = 0) ifTrue: [ SnakeUI snakeHeadUp displayOn: aGC at: (board snake first) ].	( board direction = 1) ifTrue: [ SnakeUI snakeHeadRight displayOn: aGC at: (board snake first) ].	( board direction = 2) ifTrue: [ SnakeUI snakeHeadDown displayOn: aGC at: (board snake first) ].	( board direction = 3) ifTrue: [ SnakeUI snakeHeadLeft displayOn: aGC at: (board snake first) ].		"drawing the food""	xpos := board food x.	ypos := board food y.	gaw := GraphicsAttributesWrapper on: pixel asFiller.	ga := GraphicsAttributes new paint: ColorValue green.	gaw attributes: ga.	gaw displayOn: aGC at: xpos @ ypos"	SnakeUI apple displayOn: aGC at: (board food).</body></methods><methods><class-id>SnakeUI</class-id> <category>initialize-release</category><body package="Snake">initialize		| board rs |	"initialization of variables"	board := Snake testBoard asValue.	self playground: SnakeView new.	self playground model: board.	self highscores: SortedCollection new.		"loading previous highscores"		rs := ('highscores' asFilename) readStream.	self highscores: (self restore: rs ).	rs close.		"printing highscores"	self printHighscores.		"updating methods"	board onChangeSend: #updateScore to: self.	board onChangeSend: #changeBoard to: self.</body></methods><methods><class-id>SnakeUI</class-id> <category>accessing</category><body package="Snake">highscores	^highscores</body><body package="Snake">highscores: anObject	highscores := anObject</body><body package="Snake">play	^play</body><body package="Snake">play: anObject	play := anObject</body><body package="Snake">playground	^playground</body><body package="Snake">playground: anObject	playground := anObject</body></methods><methods><class-id>SnakeUI</class-id> <category>actions</category><body package="Snake">killProcess"kills the process ; warning : everything post terminate message will not work"	"checking if is a highscore"	| scr ws |	scr := self playground model value score.	( self highscores size &lt; 10 ) 	ifTrue: [ self addHighscore ]	ifFalse: [ (scr &gt; (self highscores last at: 2)) ifTrue: [ self highscores removeLast. self addHighscore ]].		"sorting highscores"	self sortHighscores.	"saving them in a file"	ws := ('highscores' asFilename) writeStream.	self printOn: ws.	ws close.	"printing them on game"	self printHighscores.		"resets the game position"		self playground model: (Snake testBoard asValue).		"reenables the play button"	(self builder componentAt: #startButton) enable.		self play terminate.</body><body package="Snake">move"move is THE FUNCTION that allows the game to properly word, here Snake :	moves 	eats	grows	runs into walls	bites himself	and the food changes position"	"initialization of our variables"	| model board newSnake snake food direction wallCheck snakeCheck boardX boardY  pixel|	model := self playground model value.	"passing model"	snake := model snake.	"important for moving"	direction := model direction.	"used for wallCheck"	board := model board.	"very important for moving, growing, repositioning the food"		pixel := model pixel.	"making our new snake"	newSnake := OrderedCollection new.	"by copying the old snake in the new a snake except the last element"	(1 to: snake size - 1) do: [ :i | newSnake add: (snake at: i) ].	"and adding a new head as first element"	(direction = 2) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y + pixel) ].	(direction = 1) ifTrue:[ newSnake addFirst: (snake first x + pixel)@(snake first y) ].	(direction = 0) ifTrue:[ newSnake addFirst: (snake first x)@(snake first y - pixel) ].	(direction = 3) ifTrue:[ newSnake addFirst: (snake first x - pixel)@(snake first y) ].		"checking if snake doesn't run into any walls"	"reason for +1 explained below in food loop"	boardX := (snake first x / pixel) asInteger + 1.	boardY := (snake first y / pixel) asInteger + 1.	wallCheck := (board at: boardY) at: boardX.	"if he does we kill him"	(wallCheck = -1) 	ifTrue: [ self killProcess ].		"checking if snake doesn't bite himself"	(2 to: snake size) do: [ :pos | ((newSnake first) = (newSnake at: pos)) ifTrue: [ self killProcess ] ].		"checking if snake got the food"	food := model food.	(newSnake first = food) ifTrue: [  | rand newScore |			"update score"			newScore := model score.			newScore := newScore + 5.			model score: newScore.							"snake grows"			(direction = 2) ifTrue:[ newSnake add: (snake last x)@(snake last y + pixel) ].			(direction = 1) ifTrue:[ newSnake add: (snake last x + pixel)@(snake last y) ].			(direction = 0) ifTrue:[ newSnake add: (snake last x)@(snake last y - pixel) ].			(direction = 3) ifTrue:[ newSnake add: (snake last x - pixel)@(snake last y) ].					"calculating new position for the food"			rand := Random new.			"we are checking if nothing already exists where we want the food to reappear"			snakeCheck := true.			wallCheck := -1.			[ (wallCheck = -1) | snakeCheck ] whileTrue:			[				snakeCheck := false.								"we add +1 because we cannot allow the value 0, plus the value width or weight is non accessible				by it"				boardX := ((rand next * model width) truncated) asInteger + 1.				boardY := ((rand next * model height) truncated) asInteger + 1.								wallCheck := (board at: boardY) at: boardX.				"we are checking that the position of the food isn't one of the snake"				"the real conversion from index to position is :				be i the index be @ the pos				@ = (i * pixel) - pixel				because if i = 1 then @ = 0				and if i = 120 then @ = i * pixel - pixel"				newSnake do: [ :pos | (pos = ((boardX * pixel  - pixel)@(boardY * pixel - pixel))) ifTrue: [ snakeCheck := true ] ]			].			"giving the model for food"			model food: (boardX * pixel - pixel) @ (boardY * pixel - pixel).			 ].	"giving the model for snake"	model snake: newSnake.		"updating application model"	self playground model value: model.	"was forced to update the score in move as it wouldn't always update it"	self updateScore.</body><body package="Snake">startPlaying	| delay |	self updateScore.	"start move processus"	self play: [		delay := Delay forMilliseconds: 50.		[true] whileTrue: 		[delay wait.		self move.]		]		fork.			(self builder componentAt: #startButton) disable.</body></methods><methods><class-id>SnakeUI</class-id> <category>changing</category><body package="Snake">changeBoard"allows the board image to go accordingly with the model"	self playground invalidate</body><body package="Snake">updateScore	| scoreField model |	model := self playground model value.	scoreField := self perform: #score.	scoreField value: model score printString.</body></methods><methods><class-id>SnakeUI</class-id> <category>aspects</category><body package="Snake">highscoresView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^highscoresView isNil		ifTrue:			[highscoresView := String new asValue]		ifFalse:			[highscoresView]</body><body package="Snake">score	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^score isNil		ifTrue:			[score := String new asValue]		ifFalse:			[score]</body></methods><methods><class-id>SnakeUI</class-id> <category>highscores</category><body package="Snake">addHighscore"adds an highscore to the collection"	| usr hs |	usr := Dialog request: 'New highscore, enter username'.	hs := self playground model value score.	(usr = '') ifTrue: [ usr := 'anonymous'  ].	self highscores add:  (Array with: usr with: hs).</body><body package="Snake">printHighscores"prints the highscores on the highscoreView"	| ws text |		"ws created to use printOn on it and thus have text which is compatible with our TextEditor #highscoresView"	ws := (String new) writeStream.	self printOn: ws.	"puts the content of our writeStream in the TextEditor"	text := self perform: #highscoresView.	text value: ws contents.		ws close.</body><body package="Snake">printOn: aWS"printing highscores on a file"	| hsCol |	hsCol := self highscores.	hsCol do: [ :s | |  usr hs |		 usr := s at: 1.		hs := s at: 2.		aWS nextPutAll: usr , ':' , hs printString.		aWS nextPut: Character cr.	]</body><body package="Snake">restore: aRS"reads a stream to restore the highscores and put them in a collection"	| tmpHS |		tmpHS := OrderedCollection new.		[ aRS atEnd ] whileFalse:[ | usr hs |		usr := aRS upTo: $:.		hs := aRS upTo: Character cr.		tmpHS add: (Array with: usr with: hs asNumber).	].	^tmpHS</body><body package="Snake">sortHighscores"sorts the highscore : highest first, lowest last"	| oc sc |	oc := self highscores.	sc := SortedCollection new.		sc sortBlock: [ :i :j | (i at: 2) &gt; (j at: 2)].	oc do: [ :s | sc add: s].		oc := sc asOrderedCollection.		self highscores: oc.</body></methods><methods><class-id>SnakeUI class</class-id> <category>interface specs</category><body package="Snake">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Snake Game' 			#min: #(#{Core.Point} 1152 658 ) 			#max: #(#{Core.Point} 1152 658 ) 			#bounds: #(#{Graphics.Rectangle} 108 80 1260 738 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 30 0 735 0 640 0 ) 					#name: #ViewHolder1 					#component: #playground ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 786 0 59 0 838 0 80 0 ) 					#name: #startButton 					#model: #startPlaying 					#label: 'Start' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 783 0 111 0 883 0 136 0 ) 					#name: #score 					#model: #score ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 785 0 168 0 1014 0 432 0 ) 					#name: #TextEditor1 					#model: #highscoresView 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 787 0 95 0 ) 					#name: #Label1 					#label: 'Score' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 788 0 151 0 ) 					#name: #Label2 					#label: 'Highscores' ) ) ) )</body></methods><methods><class-id>SnakeUI class</class-id> <category>resources</category><body package="Snake">apple	"Tools.UIMaskEditor new openOnClass: self andSelector: #apple"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[32 48 0 0 168 192 0 0 170 192 0 0 0 192 0 0 21 213 64 0 21 213 64 0 21 85 64 0 21 85 64 0 21 85 64 0 21 85 64 0])</body><body package="Snake">snakeBody	"Tools.UIMaskEditor new openOnClass: self andSelector: #snakeBody"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[137 0 0 0 96 192 0 0 17 128 0 0 73 128 0 0 128 192 0 0 43 0 0 0 25 128 0 0 136 0 0 0 74 0 0 0 43 64 0 0])</body><body package="Snake">snakeHeadDown	"Tools.UIMaskEditor new openOnClass: self andSelector: #snakeHeadDown"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[255 175 240 0 255 175 240 0 255 175 240 0 95 175 80 0 95 175 80 0 255 175 240 0 255 175 240 0 10 170 0 0 14 171 0 0 15 175 0 0])</body><body package="Snake">snakeHeadLeft	"Tools.UIMaskEditor new openOnClass: self andSelector: #snakeHeadLeft"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[3 215 240 0 3 215 240 0 251 255 240 0 235 255 240 0 170 170 160 0 170 170 160 0 235 255 240 0 251 255 240 0 3 215 240 0 3 215 240 0])</body><body package="Snake">snakeHeadRight	"Tools.UIMaskEditor new openOnClass: self andSelector: #snakeHeadRight"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[253 124 0 0 253 124 0 0 255 254 240 0 255 254 176 0 170 170 160 0 170 170 160 0 255 254 176 0 255 254 240 0 253 124 0 0 253 124 0 0])</body><body package="Snake">snakeHeadUp	"Tools.UIMaskEditor new openOnClass: self andSelector: #snakeHeadUp"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@10 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[15 175 0 0 14 171 0 0 10 170 0 0 255 175 240 0 255 175 240 0 95 175 80 0 95 175 80 0 255 175 240 0 255 175 240 0 255 175 240 0])</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class></st-source>